---
description: Always use when working with Supabase via MCP/CLI
globs: 
alwaysApply: false
---
# agent-requested/supabase.mdc

## [CRITICAL] Database Branch Management

**ALWAYS** work in appropriate environment branch (staging vs production)**

- **ALWAYS** verify current branch before making changes
  TEST: Run "List branches" to see available environments and current selection
  CORRECT: Check branch status before any database operations
  INCORRECT: Making changes without knowing which environment you're targeting

- **ALWAYS** use staging branch for development and testing
  TEST: Switch to staging before creating/testing new features
  ```bash
  # CORRECT - Use staging for development
  supabase branches checkout staging
  supabase db push  # Now applies to staging
  
  # INCORRECT - Working directly on main/production
  supabase db push  # Without confirming branch
  ```

- **NEVER** test unverified features on production branch
  TEST: All new migrations and functions MUST be tested on staging first
  CORRECT: staging → test → main workflow
  INCORRECT: Direct changes to main/production branch

- **ALWAYS** switch branches explicitly using MCP or CLI
  TEST: Branch switching should be intentional and verified
  ```bash
  # CORRECT - Explicit branch management
  supabase branches list                    # See available branches
  supabase branches checkout staging        # Switch to staging
  supabase branches checkout main          # Switch to production
  
  # INCORRECT - Assuming current branch
  supabase db push  # Without branch verification
  ```

- **ALWAYS** verify branch after switching
  TEST: Confirm you're on the intended branch before proceeding
  CORRECT: Check project_id matches expected environment
  INCORRECT: Proceeding without branch confirmation

## [CRITICAL] MCP Connection and Authentication

**Use when working with Supabase via Cursor's MCP integration through composio.dev**

- **ALWAYS** verify MCP connection before starting work with Supabase operations
  TEST: Run "check my MCP server supabase connection" and confirm authorization
  CORRECT: Ask Cursor to list projects first to verify connection (Project: 1981 LLC dba Stealth Seller)
  INCORRECT: Attempting database operations without verifying MCP status
    DB PASSWORD: 9wOgb38imVsNn1Kr
- **NEVER** expose Supabase service role keys in prompts or code
  TEST: Only anon keys should be visible in client-side code
  CORRECT: Use proper environment variable management as defined in security standards
  INCORRECT: Hardcoding service_role keys in any accessible code

- **ALWAYS** specify project context when working with multiple Supabase projects
  TEST: Confirm Cursor knows which specific project to target
  CORRECT: "For this project, work with the challenge project database"
  INCORRECT: Generic commands without project specification

## [CRITICAL] Edge Functions Security

- **ALWAYS** validate authorization headers explicitly in Edge Functions
  TEST: Every function should check Authorization header presence and validity
  ```typescript
  // CORRECT
  const authorization = req.headers.get('Authorization');
  if (!authorization) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), { 
      status: 401, 
      headers: corsHeaders 
    });
  }
  
  // INCORRECT
  // Assuming user is authenticated without verification
  ```

- **NEVER** bypass JWT validation in production Edge Functions
  TEST: Remove `--no-verify-jwt` flag for production deployments
  CORRECT: `supabase functions deploy function-name --project-ref PROJECT_REF`
  INCORRECT: `supabase functions deploy function-name --no-verify-jwt`

## [CRITICAL] CORS Configuration

- **ALWAYS** handle OPTIONS preflight requests first in Edge Functions
  TEST: OPTIONS method check should be at the top of function logic
  ```typescript
  // CORRECT
  if (req.method === "OPTIONS") {
    return new Response(null, { status: 204, headers: corsHeaders });
  }
  
  // INCORRECT - OPTIONS check after other logic
  if (req.method === "POST") { /* ... */ }
  if (req.method === "OPTIONS") { /* ... */ }
  ```

- **ALWAYS** include CORS headers in ALL responses, including errors
  TEST: Every Response object should include corsHeaders
  ```typescript
  // CORRECT
  return new Response(JSON.stringify(data), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    status: 200
  });
  
  // INCORRECT - Missing CORS headers
  return new Response(JSON.stringify(data));
  ```

## [IMPORTANT] CLI Usage Patterns

- **ALWAYS** use project reference flag for remote operations
  TEST: All remote CLI commands should include `--project-ref PROJECT_REF`
  CORRECT: `supabase functions deploy add-seller --project-ref stznyutjaayimesomksk`
  INCORRECT: `supabase functions deploy add-seller` (missing project ref)

- **ALWAYS** test functions locally before deployment
  TEST: Run `supabase functions serve function-name` before deploy
  CORRECT: Local testing workflow → remote deployment
  INCORRECT: Direct deployment without local testing

- **NEVER** use `--no-backup` flag without explicit data preservation
  TEST: Verify data backup exists before using --no-backup
  CORRECT: `supabase db dump --local > backup.sql` then `supabase stop --no-backup`
  INCORRECT: `supabase stop --no-backup` without backup

## [IMPORTANT] Error Handling Standards

- **ALWAYS** return consistent error response format
  TEST: All errors should follow same JSON structure
  ```typescript
  // CORRECT
  return new Response(
    JSON.stringify({ error: 'User-friendly message' }),
    { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }
  );
  
  // INCORRECT
  return new Response('Error occurred', { status: 400 });
  ```

- **ALWAYS** log detailed errors for debugging while returning sanitized user messages
  TEST: Console logs should contain debug info, responses should be user-safe
  CORRECT: `console.error(fullError); return sanitizedResponse;`
  INCORRECT: Returning raw error objects to client

## [IMPORTANT] Function Development

- **ALWAYS** keep Edge Functions focused on single responsibility
  TEST: Function should have one clear purpose
  CORRECT: Separate functions for create, read, update, delete operations
  INCORRECT: One function handling multiple unrelated operations

- **ALWAYS** minimize dependencies to reduce cold start time
  TEST: Import only necessary modules
  CORRECT: Import specific functions: `import { serve } from 'std/http'`
  INCORRECT: Importing entire libraries for single function use

- **NEVER** use Node.js-specific APIs in Edge Functions
  TEST: Code should run on Deno runtime
  CORRECT: Use Deno standard library and Web APIs
  INCORRECT: Using Node.js `fs`, `path`, or `process` modules

## [PREFERRED] MCP Workflow Optimization

- **PREFER** having Cursor list available Supabase projects before starting work
  TEST: Verify project access and selection
  CORRECT: "List my Supabase projects" → select specific project
  INCORRECT: Assuming project availability

- **PREFER** asking Cursor to verify table schemas before database operations
  TEST: Confirm table structure matches expectations
  CORRECT: "List tables in this project" → confirm schema
  INCORRECT: Making assumptions about database structure

## [PREFERRED] Local Development

- **PREFER** using local Supabase stack for development
  TEST: Local services running at localhost:54321
  CORRECT: `supabase start` → develop locally → `supabase stop`
  INCORRECT: Developing directly against production

- **PREFER** committing migrations before deployment
  TEST: Migration files should be in version control
  CORRECT: Generate migration → commit → deploy
  INCORRECT: Manual database changes without migrations

## [PREFERRED] Deployment Verification

- **PREFER** checking function logs after deployment
  TEST: Verify successful deployment and operation
  CORRECT: `supabase functions logs function-name --project-ref PROJECT_REF`
  INCORRECT: Deploying without verification

- **PREFER** testing deployed functions with real requests
  TEST: Function responds correctly in production environment
  CORRECT: Test with curl or HTTP client after deployment
  INCORRECT: Assuming deployment success without testing

## [CRITICAL] Production Deployment Process

**Recommended workflow for deploying staging schema to production:**

```bash
# 1. Pull current staging schema to create migration file
supabase db pull

# 2. Verify migration file looks correct
supabase migration list

# 3. Switch to production project 
supabase link --project-ref [PRODUCTION_PROJECT_ID]

# 4. Deploy migrations to production
supabase db push

# OR deploy everything (functions + migrations)
supabase deploy
```

## [IMPORTANT] Migration Commands Reference

- **`supabase db pull`** - Pulls remote schema and creates migration files
- **`supabase db push`** - Pushes local migrations to remote database  
- **`supabase deploy`** - Deploys both edge functions AND migrations to production
- **`supabase migration list`** - Shows local vs remote migration history
- **`supabase migration repair [ID] --status applied`** - Fixes migration history discrepancies

## [IMPORTANT] Alternative: Manual Migration

- **Supabase Dashboard** → Production project → SQL Editor
- **Paste the exact SQL** from the tasks file  
- **Execute** the migration directly